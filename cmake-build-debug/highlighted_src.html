<pre>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltalgorithm&gt</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltfstream&gt</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltiostream&gt</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltsstream&gt</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltstring&gt</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">&ltvector&gt</span>

<span style="color:#C19600;">#include </span><span style="color:#339900;">"Kollekcio.hpp"</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">"Kor.hpp"</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">"Nszog.hpp"</span>
<span style="color:#C19600;">#include </span><span style="color:#339900;">"Sikidom.hpp"</span>

<span style="color:#C19600;">#include </span><span style="color:#339900;">"gtest_lite.h"</span>
<span style="color:#666666;">//#include "memtrace.h"</span>

<span style="color:#C19600;">#define </span><span style="color:#339900;">TESZT</span>

<span style="color:#007FA2;">std::</span>vector<<span style="color:#0000ff;">int</span>> v;
<span style="color:#007FA2;">std::</span>vector<<span style="color:#007FA2;">std::</span>unique_ptr<<span style="color:#0000ff;">int</span>>> v2;
<span style="color:#007FA2;">std::</span>vector<span style="color:#007FA2;">&ltDateTime&gt</span> v3;

<span style="color:#0000ff;">namespace</span>
{
    <span style="color:#666666;">// I don't want to #include &ltalgorithm&gt for a single function template :)</span>
    <span style="color:#0000ff;">template</span> <<span style="color:#0000ff;">typename</span> T>
    <span style="color:#0000ff;">void</span> my_swap(T& x, T& y)
    {
        T z(x);
        x = y;
        y = z;
    }

    <span style="color:#0000ff;">typedef</span> <span style="color:#0000ff;">unsigned</span> <span style="color:#0000ff;">char</span> byte;

    <span style="color:#0000ff;">const</span> byte CANARY[] = {<span style="color:#0000ff;">0</span>x5A, <span style="color:#0000ff;">0</span>xFE, <span style="color:#0000ff;">0</span>x6A, <span style="color:#0000ff;">0</span>x8D,
                           <span style="color:#0000ff;">0</span>x5A, <span style="color:#0000ff;">0</span>xFE, <span style="color:#0000ff;">0</span>x6A, <span style="color:#0000ff;">0</span>x8D,
                           <span style="color:#0000ff;">0</span>x5A, <span style="color:#0000ff;">0</span>xFE, <span style="color:#0000ff;">0</span>x6A, <span style="color:#0000ff;">0</span>x8D,
                           <span style="color:#0000ff;">0</span>x5A, <span style="color:#0000ff;">0</span>xFE, <span style="color:#0000ff;">0</span>x6A, <span style="color:#0000ff;">0</span>x8D};

    <span style="color:#0000ff;">bool</span> canary_dead(<span style="color:#0000ff;">const</span> byte* cage)
    {
        <span style="color:#0000ff;">bool</span> dead = memcmp(cage, CANARY, <span style="color:#0000ff;">sizeof</span> CANARY);
        <span style="color:#0000ff;">if</span> (dead)
        {
            <span style="color:#0000ff;">for</span> (size_t i = <span style="color:#0000ff;">0</span>; i < <span style="color:#0000ff;">sizeof</span> CANARY; ++i)
            {
                byte b = cage[i];
                printf(b == CANARY[i] ? <span style="color:#339900;">"__ "</span> : <span style="color:#339900;">"%2X "</span>, b);
            }
            putchar(<span style="color:#339900;">'<span style="color:#000000;"><b>\n</b></span>'</span>);
        }
        <span style="color:#0000ff;">return</span> dead;
    }

    <span style="color:#0000ff;">enum</span> kind_of_memory {AVAILABLE, TOMBSTONE, NON_ARRAY_MEMORY, ARRAY_MEMORY};

    <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span>* kind_string[] = {<span style="color:#0000ff;">0</span>, <span style="color:#0000ff;">0</span>, <span style="color:#339900;">"non-array memory"</span>, <span style="color:#339900;">"    array memory"</span>};

    <span style="color:#0000ff;">struct</span> metadata
    {
        byte* address;
        size_t size;
        kind_of_memory kind;

        <span style="color:#0000ff;">bool</span> in_use() <span style="color:#0000ff;">const</span>
        {
            <span style="color:#0000ff;">return</span> kind & <span style="color:#0000ff;">2</span>;
        }

        <span style="color:#0000ff;">void</span> print() <span style="color:#0000ff;">const</span>
        {
            printf(<span style="color:#339900;">"%s at %p (%d bytes)<span style="color:#000000;"><b>\n</b></span>"</span>, kind_string[kind], address, size);
        }

        <span style="color:#0000ff;">bool</span> must_keep_searching_for(<span style="color:#0000ff;">void</span>* address)
        {
            <span style="color:#0000ff;">return</span> kind == TOMBSTONE || (in_use() && address != this->address);
        }

        <span style="color:#0000ff;">bool</span> canaries_alive() <span style="color:#0000ff;">const</span>
        {
            <span style="color:#0000ff;">bool</span> alive = <span style="color:#0000ff;">true</span>;
            <span style="color:#0000ff;">if</span> (canary_dead(address - <span style="color:#0000ff;">sizeof</span> CANARY))
            {
                printf(<span style="color:#339900;">"ERROR:    buffer underflow at %p<span style="color:#000000;"><b>\n</b></span>"</span>, address);
                alive = <span style="color:#0000ff;">false</span>;
            }
            <span style="color:#0000ff;">if</span> (canary_dead(address + size))
            {
                printf(<span style="color:#339900;">"ERROR:     buffer overflow at %p<span style="color:#000000;"><b>\n</b></span>"</span>, address);
                alive = <span style="color:#0000ff;">false</span>;
            }
            <span style="color:#0000ff;">return</span> alive;
        }
    };

    <span style="color:#0000ff;">const</span> size_t MINIMUM_CAPACITY = <span style="color:#0000ff;">11</span>;

    <span style="color:#0000ff;">class</span> hashtable
    {
        metadata* data;
        size_t used;
        size_t capacity;
        size_t tombstones;

    public:

        size_t size() <span style="color:#0000ff;">const</span>
        {
            <span style="color:#0000ff;">return</span> used - tombstones;
        }

        <span style="color:#0000ff;">void</span> print() <span style="color:#0000ff;">const</span>
        {
            <span style="color:#0000ff;">for</span> (size_t i = <span style="color:#0000ff;">0</span>; i < capacity; ++i)
            {
                <span style="color:#0000ff;">if</span> (data[i].in_use())
                {
                    printf(<span style="color:#339900;">":( leaked "</span>);
                    data[i].print();
                }
            }
        }

        hashtable()
        {
            used = <span style="color:#0000ff;">0</span>;
            capacity = MINIMUM_CAPACITY;
            data = static_cast<metadata*>(calloc(capacity, <span style="color:#0000ff;">sizeof</span>(metadata)));
            tombstones = <span style="color:#0000ff;">0</span>;
        }

        hashtable()
        {
            free(data);
        }

        hashtable(<span style="color:#0000ff;">const</span> hashtable& that)
        {
            used = <span style="color:#0000ff;">0</span>;
            capacity = <span style="color:#0000ff;">3</span> * that.size() | <span style="color:#0000ff;">1</span>;
            <span style="color:#0000ff;">if</span> (capacity < MINIMUM_CAPACITY) capacity = MINIMUM_CAPACITY;
            data = static_cast<metadata*>(calloc(capacity, <span style="color:#0000ff;">sizeof</span>(metadata)));
            tombstones = <span style="color:#0000ff;">0</span>;

            <span style="color:#0000ff;">for</span> (size_t i = <span style="color:#0000ff;">0</span>; i < that.capacity; ++i)
            {
                <span style="color:#0000ff;">if</span> (that.data[i].in_use())
                {
                    insert_unsafe(that.data[i]);
                }
            }
        }

        hashtable& operator=(hashtable copy)
        {
            swap(copy);
            <span style="color:#0000ff;">return</span> *this;
        }

        <span style="color:#0000ff;">void</span> swap(hashtable& that)
        {
            my_swap(data, that.data);
            my_swap(used, that.used);
            my_swap(capacity, that.capacity);
            my_swap(tombstones, that.tombstones);
        }

        <span style="color:#0000ff;">void</span> insert_unsafe(<span style="color:#0000ff;">const</span> metadata& x)
        {
            *find(x.address) = x;
            ++used;
        }

        <span style="color:#0000ff;">void</span> insert(<span style="color:#0000ff;">const</span> metadata& x)
        {
            <span style="color:#0000ff;">if</span> (<span style="color:#0000ff;">2</span> * used >= capacity)
            {
                hashtable copy(*this);
                swap(copy);
            }
            insert_unsafe(x);
        }

        metadata* find(<span style="color:#0000ff;">void</span>* address)
        {
            size_t index = reinterpret_cast<size_t>(address) % capacity;
            <span style="color:#0000ff;">while</span> (data[index].must_keep_searching_for(address))
            {
                ++index;
                <span style="color:#0000ff;">if</span> (index == capacity) index = <span style="color:#0000ff;">0</span>;
            }
            <span style="color:#0000ff;">return</span> &data[index];
        }

        <span style="color:#0000ff;">void</span> erase(metadata* it)
        {
            it->kind = TOMBSTONE;
            ++tombstones;
        }
    } the_hashset;

    <span style="color:#0000ff;">struct</span> heap_debugger
    {
        heap_debugger()
        {
            puts(<span style="color:#339900;">"heap debugger started"</span>);
        }

        heap_debugger()
        {
            the_hashset.print();
            puts(<span style="color:#339900;">"heap debugger shutting down"</span>);
        }
    } the_heap_debugger;

    <span style="color:#0000ff;">void</span>* allocate(size_t size, kind_of_memory kind) <span style="color:#0000ff;">throw</span> (<span style="color:#007FA2;">std::</span>bad_alloc)
    {
        byte* raw = static_cast<byte*>(malloc(size + <span style="color:#0000ff;">2</span> * <span style="color:#0000ff;">sizeof</span> CANARY));
        <span style="color:#0000ff;">if</span> (raw == <span style="color:#0000ff;">0</span>) <span style="color:#0000ff;">throw</span> <span style="color:#007FA2;">std::</span>bad_alloc();

        memcpy(raw, CANARY, <span style="color:#0000ff;">sizeof</span> CANARY);
        byte* payload = raw + <span style="color:#0000ff;">sizeof</span> CANARY;
        memcpy(payload + size, CANARY, <span style="color:#0000ff;">sizeof</span> CANARY);

        metadata md = {payload, size, kind};
        the_hashset.insert(md);
        printf(<span style="color:#339900;">"allocated "</span>);
        md.print();
        <span style="color:#0000ff;">return</span> payload;
    }

    <span style="color:#0000ff;">void</span> release(<span style="color:#0000ff;">void</span>* payload, kind_of_memory kind) <span style="color:#0000ff;">throw</span> ()
    {
        <span style="color:#0000ff;">if</span> (payload == <span style="color:#0000ff;">0</span>) <span style="color:#0000ff;">return</span>;

        metadata* p = the_hashset.find(payload);

        <span style="color:#0000ff;">if</span> (!p->in_use())
        {
            printf(<span style="color:#339900;">"ERROR:   no dynamic memory at %p<span style="color:#000000;"><b>\n</b></span>"</span>, payload);
        }
        <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> (p->kind != kind)
        {
            printf(<span style="color:#339900;">"ERROR:wrong form of delete at %p<span style="color:#000000;"><b>\n</b></span>"</span>, payload);
        }
        <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> (p->canaries_alive())
        {
            printf(<span style="color:#339900;">"releasing "</span>);
            p->print();
            free(static_cast<byte*>(payload) - <span style="color:#0000ff;">sizeof</span> CANARY);
            the_hashset.erase(p);
        }
    }
}

<span style="color:#0000ff;">void</span>* <span style="color:#0000ff;">operator</span> <span style="color:#0000ff;">new</span>(size_t size) <span style="color:#0000ff;">throw</span> (<span style="color:#007FA2;">std::</span>bad_alloc)
{
    <span style="color:#0000ff;">return</span> allocate(size, NON_ARRAY_MEMORY);
}

<span style="color:#0000ff;">void</span>* <span style="color:#0000ff;">operator</span> new[](size_t size) <span style="color:#0000ff;">throw</span> (<span style="color:#007FA2;">std::</span>bad_alloc)
{
    <span style="color:#0000ff;">return</span> allocate(size, ARRAY_MEMORY);
}

<span style="color:#0000ff;">void</span> <span style="color:#0000ff;">operator</span> <span style="color:#0000ff;">delete</span>(<span style="color:#0000ff;">void</span>* payload) <span style="color:#0000ff;">throw</span> ()
{
    release(payload, NON_ARRAY_MEMORY);
}

<span style="color:#0000ff;">void</span> <span style="color:#0000ff;">operator</span> delete[](<span style="color:#0000ff;">void</span>* payload) <span style="color:#0000ff;">throw</span> ()
{
    release(payload, ARRAY_MEMORY);
}

<span style="color:#0000ff;">int</span> main()
{
    <span style="color:#C19600;">#ifndef </span><span style="color:#339900;">TESZT</span>
    <span style="color:#007FA2;">std::</span><span style="color:#007FA2;">ios_base::</span>sync_with_stdio(<span style="color:#0000ff;">false</span>);

    Kollekcio<Sikidom*> kollekcio;

    <span style="color:#007FA2;">std::</span>ifstream txtfajl(<span style="color:#339900;">"alakzatok.txt"</span>);
    <span style="color:#007FA2;">std::</span>string sor;

    <span style="color:#0000ff;">if</span>(txtfajl.is_open())
    {
        <span style="color:#0000ff;">while</span>(<span style="color:#007FA2;">std::</span>getline(txtfajl, sor))
        {
            <span style="color:#007FA2;">std::</span>istringstream iss(sor);

            Pont2D kp;
            Pont2D csp;

            <span style="color:#0000ff;">if</span>(sor.find(<span style="color:#339900;">"k"</span>) != <span style="color:#007FA2;">std::</span><span style="color:#007FA2;">string::</span>npos)
            {
                <span style="color:#0000ff;">char</span> c;
                iss >> c >> kp >> csp;
                kollekcio.push_back(<span style="color:#0000ff;">new</span> Kor(kp, csp));

            } <span style="color:#0000ff;">else</span> {
                <span style="color:#0000ff;">int</span> n;
                iss >> n >> kp >> csp;
                kollekcio.push_back(<span style="color:#0000ff;">new</span> Nszog(kp, csp, n));
            }
        }
    }

    txtfajl.close();

    Pont2D sajat_pont;

    <span style="color:#007FA2;">std::</span>cout << <span style="color:#339900;">"Adjon meg egy pontot: "</span> << <span style="color:#007FA2;">std::</span>endl;
    <span style="color:#007FA2;">std::</span>cin >> sajat_pont;

    <span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">unsigned</span> <span style="color:#0000ff;">int</span> i = <span style="color:#0000ff;">0</span>; i < kollekcio.size(); i++)
    {
        <span style="color:#0000ff;">if</span>(kollekcio[i]->benne_van(sajat_pont))
        {
            kollekcio[i]->kiir();
        }
    }

    <span style="color:#C19600;">#endif</span>


    <span style="color:#666666;">/// JPORTÁS TESZTEK</span>
    <span style="color:#C19600;">#ifdef </span><span style="color:#339900;">TESZT</span>
    Kollekcio kollekcio;


    TEST(Test1, kollekcio_hozzaadogatos_teszt)
    {
        EXPECT_EQ((size_t)0, kollekcio.size())          << <span style="color:#339900;">"default konstruktor nem 0-at ad meretnek"</span> << <span style="color:#007FA2;">std::</span>endl;
        E</span>PECT_EQ((size_t)<span style="color:#0000ff;">10</span>, kollekcio.capacity())     << <span style="color:#339900;">"hibas kezdeti kapacitas"</span> << <span style="color:#007FA2;">std::</span>endl;

        kollekcio.push_back(<span style="color:#0000ff;">new</span> Nszog({<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">0</span>}, {<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">1</span>}, <span style="color:#0000ff;">15</span>));
        E</span>PECT_EQ((size_t)<span style="color:#0000ff;">1</span>, kollekcio.size())          << <span style="color:#339900;">"nem no a meret uj elem hozzavetelenel"</span> << <span style="color:#007FA2;">std::</span>endl;

        <span style="color:#666666;">/// mi van ha elérjük a kollekció kapacitásának maximumát?</span>
        <span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i = <span style="color:#0000ff;">0</span>; i < <span style="color:#0000ff;">10</span>; i++)
        {
            kollekcio.push_back(<span style="color:#0000ff;">new</span> Kor({<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">0</span>}, {<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">1</span>}));
        }

        E</span>PECT_EQ((size_t)<span style="color:#0000ff;">20</span>, kollekcio.capacity())     << <span style="color:#339900;">"nem duplazta meg a kollekcionak lefoglalt helyet I."</span> << <span style="color:#007FA2;">std::</span>endl;

        <span style="color:#666666;">/// és ha megint?</span>
        <span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i = <span style="color:#0000ff;">0</span>; i < <span style="color:#0000ff;">10</span>; i++)
        {
            kollekcio.push_back(<span style="color:#0000ff;">new</span> Kor({<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">0</span>}, {<span style="color:#0000ff;">0</span>,<span style="color:#0000ff;">1</span>}));
        }

        E</span>PECT_EQ((size_t)<span style="color:#0000ff;">40</span>, kollekcio.capacity())     << <span style="color:#339900;">"nem duplazta meg a kollekcionak lefoglalt helyet II."</span> << <span style="color:#007FA2;">std::</span>endl;
    } ENDM

    TEST(Test2, tulindexeleses_teszt)
    {
        <span style="color:#666666;">/// a kollekciónk mérete az elõzõ teszt után 21, azaz a 20.indexig nem várunk kivételt</span>
        E</span>PECT_NO_THROW(kollekcio[<span style="color:#0000ff;">20</span>]);
        <span style="color:#666666;">/// a 20.-nál már várunk</span>
        E</span>PECT_THROW(kollekcio[<span style="color:#0000ff;">21</span>], <span style="color:#007FA2;">std::</span>out_of_range);
    } ENDM

    TEST(Test3, belso_pont_teszt)
    {
        <span style="color:#666666;">/// felhasználjuk kollekcio[0]-át, ami egy origó középpontó egység sugarú kör</span>

        <span style="color:#666666;">/// (1/2, 1/2) pont benne van</span>
        Pont2D p = {<span style="color:#0000ff;">0.5</span>, <span style="color:#0000ff;">0.5</span>};
        E</span>PECT_TRUE(kollekcio[<span style="color:#0000ff;">0</span>]->benne_van(p))         << <span style="color:#339900;">"az origo pedig belso pont"</span> << <span style="color:#007FA2;">std::</span>endl;

        <span style="color:#666666;">/// a (0, 1) pont a körvonalon van, ezt nem fogadjuk el belsõ pontnak</span>
        p = {<span style="color:#0000ff;">0.0</span>, <span style="color:#0000ff;">1.0</span>};
        E</span>PECT_FALSE(kollekcio[<span style="color:#0000ff;">0</span>]->benne_van(p))        << <span style="color:#339900;">"a korvonal nem belso pont!"</span> << <span style="color:#007FA2;">std::</span>endl;

        <span style="color:#666666;">/// a (100, 100) pont nyilván kivül esik</span>
        p = {<span style="color:#0000ff;">100</span>, <span style="color:#0000ff;">100</span>};
        E</span>PECT_FALSE(kollekcio[<span style="color:#0000ff;">0</span>]->benne_van(p));


        <span style="color:#666666;">/// hasonló próbák egy (1, 1) középpontú négyzettel, aminek egyik csúcsa a (0, 0);</span>
        Nszog negyzet({<span style="color:#0000ff;">1</span>, <span style="color:#0000ff;">1</span>}, {<span style="color:#0000ff;">0</span>, <span style="color:#0000ff;">0</span>}, <span style="color:#0000ff;">4</span>);

        <span style="color:#666666;">/// belsõ pont</span>
        p = {<span style="color:#0000ff;">0.2</span>, <span style="color:#0000ff;">1.8</span>};
        E</span>PECT_TRUE(negyzet.benne_van(p));

        <span style="color:#666666;">/// egy csúcs</span>
        p = {<span style="color:#0000ff;">2</span>, <span style="color:#0000ff;">2</span>};
        E</span>PECT_FALSE(negyzet.benne_van(p));

        <span style="color:#666666;">/// külsõ pont</span>
        p = {<span style="color:#0000ff;">100</span>, <span style="color:#0000ff;">100</span>};
        E</span>PECT_FALSE(negyzet.benne_van(p));
    } ENDM

    <span style="color:#0000ff;">for</span>(<span style="color:#007FA2;">Kollekcio::</span>iterator iter = kollekcio.begin(); iter != kollekcio.end(); ++iter)
    {
        <span style="color:#0000ff;">delete</span> *iter;
        *iter = NULL;
    }


    <span style="color:#666666;">/*int i = 0;
    for(Sikidom* s : kollekcio)
    {
        std::cout << s << std::endl;
        std::cout << i++ << std::endl;
        if(s != NULL)
        {
            delete s;
        }
    }*/</span>

    <span style="color:#666666;">/*int i = 0;
    for(Kollekcio::iterator iter = kollekcio.begin(); iter != kollekcio.end(); ++iter)
    {
        std::cout << i++ << std::endl;

        delete *iter;
    }*/</span>

    <span style="color:#C19600;">#endif</span>

    <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">0</span>;
}
</pre>
